## 日志
- 写操作日志
  - **先写日志，再写数据库**
  - 明明日志记录的信息比数据库本身还要多，为什么还要区分日志和数据库
    - 数据库数据本身的组织结构更高效，它只保留当前值、存储布局考虑效率、存在索引；日志记录是Pile起来的、基本没有结构
  - 记录组成：
    - `<tid, key, old_val, new_val>`表示command ID、修改的键、旧值、新值
- 幂等操作
  - 所有操作都设计成幂等的
  - **key不存在与value对应为null完全等价**
  - 由此有：
    - `Get`不存在的key返回空值
    - `Set`不存在的key等价于`value: null -> new`
    - `Del`等价于`value: old -> null`
    - 存在性等价于判断value是否为空
    - 日志操作也可以统一为这两类
- 持久化
  - 简化设计，我们假设**整个数据表都是in-memory的**（这可以通过某些策略扩展为可行的持久化）
  - 但是，**日志是持久化的**
  - 每次宕机，由于表数据是非持久化的，则必须**全部数据从日志Redo恢复**
- 客户一致性问题
  - 为了简化设计，采用*会话语义*。**只要客户端断开连接，会话结束**
  - 客户端必须维护读写集，或者简化的类似数据结构，以便在移动到不同副本上的时候实现客户一致性
  - 因为记录客户端的每条command是否被commit是共识，但是否被applied却不是。这里的隐患是：读写一致性:在前一个副本上写了，在后一个副本上读，虽然写操作commit了，但可能还没被applied，导致在后一个副本上读到了写之前的值
- 并发访问问题
  - 由于Raft是Leader-based，所以上锁问题可以全部交给leader
  - 采用经典的读写锁。读上共享锁，写上排他锁
- 服务器状态问题与客户一致性问题
  - 所有操作都是幂等的所以**不需要exactly-once语义，只需要at-least-once语义**
  - 先尝试无状态
  - 可能的无状态实现：基于客户端的读写集记录。
    - 以读写一致性为例，**利用请求中附带的写集信息，如果该读操作还没有及时applied，查找日志，查证后优先applied**
  - 注意到commit是共识，所以如果一个操作是有效的，那它一定会被日志记录到本地（除非这个写操作还未commit，那就只能block了）；另外，因为幂等操作，单独拎出来apply，后面在被重复apply是没有危害的